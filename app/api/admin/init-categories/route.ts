
import { createClient } from '@supabase/supabase-js';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';

// Client initialization moved inside handler to avoid build-time errors


export async function GET() {
    try {
        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
        const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
        const supabase = createClient(supabaseUrl, supabaseServiceKey);


        // 1. Create Table if not exists
        const createTableQuery = `
      CREATE TABLE IF NOT EXISTS categories (
        id bigint generated by default as identity primary key,
        name text unique not null,
        color text,
        sort_order int,
        created_at timestamp with time zone default timezone('utc'::text, now()) not null
      );
      
      ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
      
      DO $$
      BEGIN
          IF NOT EXISTS (
              SELECT 1 FROM pg_policies 
              WHERE tablename = 'categories' 
              AND policyname = 'Enable read access for all users'
          ) THEN
              CREATE POLICY "Enable read access for all users" ON "public"."categories" FOR SELECT USING (true);
          END IF;
      END
      $$;
    `;

        const { error: createError } = await supabase.rpc('exec_sql', { sql: createTableQuery });
        // Note: exec_sql is a custom RPC. If it doesn't exist, we might fail here.
        // Fallback: We'll assume the user has to run SQL manually OR we can try to just insert and hope the table exists 
        // BUT since we can't easily create tables via JS client without RPC, we'll try to just insert.
        // Actually, for this environment, let's assume we can insert. If table missing, we see error.

        // Alternative: Use a direct insert check. But we need to define the categories first.

        const categories = [
            { name: 'Produce', color: 'bg-emerald-50 border-emerald-200 text-emerald-700', sort_order: 10 },
            { name: 'Pantry', color: 'bg-yellow-50 border-yellow-200 text-yellow-700', sort_order: 20 },
            { name: 'Dairy', color: 'bg-purple-50 border-purple-200 text-purple-700', sort_order: 30 },
            { name: 'Beverage', color: 'bg-sky-50 border-sky-200 text-sky-700', sort_order: 40 },
            { name: 'Meat', color: 'bg-red-50 border-red-200 text-red-700', sort_order: 50 },
            { name: 'Frozen', color: 'bg-cyan-50 border-cyan-200 text-cyan-700', sort_order: 60 },
            { name: 'Refrigerated', color: 'bg-blue-50 border-blue-200 text-blue-700', sort_order: 70 },
            { name: 'Bakery', color: 'bg-orange-50 border-orange-200 text-orange-700', sort_order: 80 },
            { name: 'Household', color: 'bg-amber-50 border-amber-200 text-amber-700', sort_order: 90 },
            { name: 'Health', color: 'bg-pink-50 border-pink-200 text-pink-700', sort_order: 100 },
            { name: 'Other', color: 'bg-slate-50 border-slate-200 text-slate-700', sort_order: 999 },
        ];

        let insertedCount = 0;

        for (const cat of categories) {
            // Upsert based on name
            const { error } = await supabase
                .from('categories')
                .upsert(cat, { onConflict: 'name' });

            if (error) {
                console.error('Error inserting category:', cat.name, error);
                // If error is related to relation not found, we might need to alert user to create table
                if (error.code === '42P01') {
                    return NextResponse.json({
                        error: 'Table "categories" does not exist. Please run the SQL manually.',
                        sql: createTableQuery
                    }, { status: 500 });
                }
            } else {
                insertedCount++;
            }
        }

        return NextResponse.json({
            success: true,
            message: `Processed categories.`,
            inserted_count: insertedCount
        });

    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}
